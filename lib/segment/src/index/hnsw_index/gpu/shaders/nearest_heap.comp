#ifndef NEAREST_HEAP_HEADER
#define NEAREST_HEAP_HEADER

#ifndef NEAREST_HEAP_LAYOUT_SET
#error "NEAREST_HEAP_LAYOUT_SET not defined"
#endif

#include "common.comp"

layout(set = NEAREST_HEAP_LAYOUT_SET, binding = 0)
buffer NearestScores {
    float data[];
} nearest_score;

layout(set = NEAREST_HEAP_LAYOUT_SET, binding = 1)
buffer NearestIds {
    uint data[];
} nearest_id;

ScoredPoint nearest_smaller;
uint nearest_smaller_index;
uint nearest_count;

#define NEAREST_BUFFER_OFFSET (NEAREST_HEAP_CAPACITY * SUBGROUP_ID)

void nearest_heap_init() {
    nearest_count = 0;
    nearest_smaller_index = 0;
    nearest_smaller = ScoredPoint(UINT_MAX, positive_infinity);

    uint buffer_offset = NEAREST_BUFFER_OFFSET;
    uint capacity = NEAREST_HEAP_CAPACITY;
    for (uint i = SUBGROUP_INVOCATION_ID; i < capacity; i += SUBGROUP_SIZE) {
        uint buffer_index = buffer_offset + i;
        nearest_score.data[buffer_index] = negative_infinity;
        nearest_id.data[buffer_index] = UINT_MAX;
    }
    groupMemoryBarrier();
}

// Push the nearest `ScoredPoint`. Returns true if the `ScoredPoint` was added.
bool push_nearest(ScoredPoint scored_point) {
    uint ef = NEAREST_HEAP_EF;
    if (nearest_count == ef) {
        if (scored_point.score > nearest_smaller.score) {
            uint buffer_offset = NEAREST_BUFFER_OFFSET;
            if (subgroupElect()) {
                uint buffer_index = buffer_offset + nearest_smaller_index;
                nearest_score.data[buffer_index] = scored_point.score;
                nearest_id.data[buffer_index] = scored_point.id;
            }
            groupMemoryBarrier(); // TODO: is this necessary? We can write and read in the same shader invocation

            nearest_smaller_index = 0;
            nearest_smaller.score = positive_infinity;
            for (uint i = SUBGROUP_INVOCATION_ID; i < ef; i += SUBGROUP_SIZE) {
                uint buffer_index = buffer_offset + i;
                float score = nearest_score.data[buffer_index];
                if (score < nearest_smaller.score) {
                    nearest_smaller.score = score;
                    nearest_smaller_index = i;
                }
            }

            float subgroup_smaller = subgroupMin(nearest_smaller.score);
            bool is_min_thread = nearest_smaller.score == subgroup_smaller;
            uvec4 subgroup_min_threads = subgroupBallot(is_min_thread);
            uint subgroup_min_thread = subgroupBallotFindLSB(subgroup_min_threads);
            nearest_smaller_index = subgroupShuffle(nearest_smaller_index, subgroup_min_thread);
            nearest_smaller.score = subgroupShuffle(nearest_smaller.score, subgroup_min_thread);
            nearest_smaller.id = nearest_id.data[nearest_smaller_index];

            return true;
        } else {
            return false;
        }
    } else {
        if (subgroupElect()) {
            uint buffer_index = NEAREST_BUFFER_OFFSET + nearest_count;
            nearest_score.data[buffer_index] = scored_point.score;
            nearest_id.data[buffer_index] = scored_point.id;
        }
        groupMemoryBarrier(); // TODO: is this necessary? We can write and read in the same shader invocation

        if (scored_point.score < nearest_smaller.score) {
            nearest_smaller = scored_point;
            nearest_smaller_index = nearest_count;
        }
        nearest_count++;
        return true;
    }
}

void bitonic_cmp(uint i, uint j) {
    uint buffer_offset = NEAREST_BUFFER_OFFSET;
    uint b_i = buffer_offset + i;
    uint b_j = buffer_offset + j;
    if (i < j && j < nearest_count && nearest_score.data[b_j] > nearest_score.data[b_i]) {
        float temp = nearest_score.data[b_i];
        nearest_score.data[b_i] = nearest_score.data[b_j];
        nearest_score.data[b_j] = temp;

        POINT_ID t = nearest_id.data[b_i];
        nearest_id.data[b_i] = nearest_id.data[b_j];
        nearest_id.data[b_j] = t;
    }
}

void sort_nearest() {
    for (uint k = 2; (k >> 1) < nearest_count; k <<= 1) {
        for (uint i = SUBGROUP_INVOCATION_ID; i < nearest_count; i += SUBGROUP_SIZE) {
            bitonic_cmp(i, i ^ (k - 1));
        }
        groupMemoryBarrier();

        for (uint j = k >> 1; 0 < j; j >>= 1) {
            for (uint i = SUBGROUP_INVOCATION_ID; i < nearest_count; i += SUBGROUP_SIZE) {
                bitonic_cmp(i, i ^ j);
            }
            groupMemoryBarrier();
        }
    }
}

ScoredPoint get_nearest(uint i) {
    uint buffer_offset = NEAREST_BUFFER_OFFSET;
    return ScoredPoint(
        nearest_id.data[buffer_offset + i],
        nearest_score.data[buffer_offset + i]
    );
}

void set_nearest(uint i, ScoredPoint scored_point) {
    if (subgroupElect()) {
        uint buffer_offset = NEAREST_BUFFER_OFFSET;
        nearest_id.data[buffer_offset + i] = scored_point.id;
        nearest_score.data[buffer_offset + i] = scored_point.score;
    }
    groupMemoryBarrier();
}

#endif
