#ifndef VECTOR_STORAGE_HEADER
#define VECTOR_STORAGE_HEADER

#ifndef VECTOR_STORAGE_LAYOUT_SET
#error "VECTOR_STORAGE_LAYOUT_SET not defined"
#endif

#ifdef VECTOR_STORAGE_ELEMENT_FLOAT32

#define VECTOR_STORAGE_ELEMENT_TYPE vec4
#define VECTOR_STORAGE_SCORE_ELEMENT(a, b) dot(a, b)

#endif

#ifdef VECTOR_STORAGE_ELEMENT_FLOAT16

#extension GL_EXT_shader_explicit_arithmetic_types_float16 : enable
#define VECTOR_STORAGE_ELEMENT_TYPE f16vec4
#define VECTOR_STORAGE_SCORE_ELEMENT(a, b) dot(a, b)

#endif

#ifdef VECTOR_STORAGE_ELEMENT_UINT8

float dot_u8vec4(u8vec4 a, u8vec4 b) {
    uint sum = uint(a.x) * uint(b.x) + uint(a.y) * uint(b.y) + uint(a.z) * uint(b.z) + uint(a.w) * uint(b.w);
    return float(sum);
}

#define VECTOR_STORAGE_ELEMENT_TYPE u8vec4
#define VECTOR_STORAGE_SCORE_ELEMENT(a, b) dot_u8vec4(a, b)

#endif

#ifdef VECTOR_STORAGE_ELEMENT_BINARY

// uint = 4 * uint8_t, vec4 analogue for BQ
#define VECTOR_STORAGE_ELEMENT_TYPE uint
#define VECTOR_STORAGE_SCORE_ELEMENT(a, b) float(bitCount(a ^ b))

#endif

#ifndef VECTOR_STORAGE_ELEMENT_TYPE
#error "VECTOR_STORAGE_ELEMENT not defined"
#endif

#include "common.comp"

#define STORAGES_COUNT 4

#define STORAGE(STORAGE_INDEX) CONCAT(vectors, STORAGE_INDEX)

#define VECTOR_STORAGE_DEFINE(STORAGE_INDEX) \
    layout(set = VECTOR_STORAGE_LAYOUT_SET, binding = STORAGE_INDEX) \
    readonly buffer CONCAT(Vectors, STORAGE_INDEX) { \
        VECTOR_STORAGE_ELEMENT_TYPE data[]; \
    } STORAGE(STORAGE_INDEX);

VECTOR_STORAGE_DEFINE(0)
VECTOR_STORAGE_DEFINE(1)
VECTOR_STORAGE_DEFINE(2)
VECTOR_STORAGE_DEFINE(3)

#if DIM / (4 * SUBGROUP_SIZE) > 1

#define VECTOR_STORAGE_SCORE_SUBGROUP(STORAGE_INDEX) \
    for (uint i = 0; i < DIM / (4 * SUBGROUP_SIZE); i++, index += SUBGROUP_SIZE) { \
        result += VECTOR_STORAGE_SCORE_ELEMENT( \
            STORAGE(STORAGE_INDEX).data[index], \
            target_cache[i] \
        ); \
    }

#define VECTOR_STORAGE_SET_TARGET(STORAGE_INDEX) \
    for (uint i = 0; i < DIM / (4 * SUBGROUP_SIZE); i++, index += SUBGROUP_SIZE) { \
        target_cache[i] = STORAGE(STORAGE_INDEX).data[index]; \
    }

VECTOR_STORAGE_ELEMENT_TYPE target_cache[DIM / (4 * SUBGROUP_SIZE)];

#else

#define VECTOR_STORAGE_SCORE_SUBGROUP(STORAGE_INDEX) \
    result += VECTOR_STORAGE_SCORE_ELEMENT( \
        STORAGE(STORAGE_INDEX).data[index], \
        target_cache \
    );

#define VECTOR_STORAGE_SET_TARGET(STORAGE_INDEX) \
    target_cache = STORAGE(STORAGE_INDEX).data[index];

VECTOR_STORAGE_ELEMENT_TYPE target_cache;

#endif

void set_target(uint point_id) {
    uint index = (point_id / STORAGES_COUNT) * (DIM / 4) + SUBGROUP_INVOCATION_ID;
    uint storage_index = point_id % STORAGES_COUNT;
    switch (storage_index) {
    case 0:
        VECTOR_STORAGE_SET_TARGET(0);
        break;
    case 1:
        VECTOR_STORAGE_SET_TARGET(1);
        break;
    case 2:
        VECTOR_STORAGE_SET_TARGET(2);
        break;
    case 3:
        VECTOR_STORAGE_SET_TARGET(3);
        break;
    }
}

float similarity(uint point_id) {
    float result = 0.0;
    uint index = (point_id / STORAGES_COUNT) * (DIM / 4) + SUBGROUP_INVOCATION_ID;
    uint storage_index = point_id % STORAGES_COUNT;
    switch (storage_index) {
    case 0:
        VECTOR_STORAGE_SCORE_SUBGROUP(0);
        break;
    case 1:
        VECTOR_STORAGE_SCORE_SUBGROUP(1);
        break;
    case 2:
        VECTOR_STORAGE_SCORE_SUBGROUP(2);
        break;
    case 3:
        VECTOR_STORAGE_SCORE_SUBGROUP(3);
        break;
    }

#ifdef VECTOR_STORAGE_ELEMENT_BINARY
    float xor_product = subgroupAdd(result);
    float zeros_count = float((DIM / 4) * 32) - xor_product;
    return zeros_count - xor_product;
#else
    return subgroupAdd(result);
#endif
}

#endif
